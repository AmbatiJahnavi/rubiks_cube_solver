# Rubik Solver

## Overview
In this project, I have learned how to model a real-world object, like a Rubik’s Cube, into something that a computer can understand. I broke down the larger problem of creating a complete Rubik’s Cube solver into smaller, manageable problems using basic models and controllers, specifically representations and solvers for the Rubik’s Cube.

## Key Concepts and Learnings

### Object-Oriented Programming (OOP)
- **Classes and Objects**: Explored the fundamental building blocks of OOP.
- **Virtual Functions and Abstract Classes**: Utilized these to create flexible and reusable code.
- **Inheritance**: Leveraged inheritance to extend base classes for specific functionalities.
- **Operator Overloading**: Implemented custom behaviors for standard operators.

### Algorithmic Approaches
- **Pathfinding Algorithms**: Used BFS, DFS, IDDFS, and IDA* to solve problems related to AI, demonstrating their real-world applications.
- **Heuristic Search Algorithms**:  Explored A* and IDA*, and learned how to create Pattern Databases to provide heuristics.

### Practical Skills
- **Data Structures**: Delved into how `unordered_map<>` works for custom objects and how to create custom hash functions.
- **Bit Manipulation**: Learned how bits can be used to store information efficiently.
- **File Handling**: Covered techniques for saving and loading files.
- **Black Boxing**: Applied the concept of black boxing, where I can provide an input and expect a specific output from a black box, such as our Permutation Indexer.

## Conclusion
Through this project, I have gained valuable insights into modeling, problem-solving, and the practical application of various programming techniques and algorithms. This foundation can be extended to solve more complex problems in the field of AI and beyond.

## Github link
