# Rubik Solver

## Overview
In this project, we learned how to model a real-world object, like a Rubik’s Cube, into something that a computer can understand. We broke down the larger problem of creating a complete Rubik’s Cube solver into smaller, manageable problems using basic models and controllers, specifically representations and solvers for the Rubik’s Cube.

## Key Concepts and Learnings

### Object-Oriented Programming (OOP)
- **Classes and Objects**: We explored the fundamental building blocks of OOP.
- **Virtual Functions and Abstract Classes**: We utilized these to create flexible and reusable code.
- **Inheritance**: We leveraged inheritance to extend base classes for specific functionalities.
- **Operator Overloading**: We implemented custom behaviors for standard operators.

### Algorithmic Approaches
- **Pathfinding Algorithms**: We used BFS, DFS, IDDFS, and IDA* to solve problems related to AI, demonstrating their real-world applications.
- **Heuristic Search Algorithms**: We explored A* and IDA*, and learned how to create Pattern Databases to provide heuristics.

### Practical Skills
- **Data Structures**: We delved into how `unordered_map<>` works for custom objects and how to create custom hash functions.
- **Bit Manipulation**: We learned how bits can be used to store information efficiently.
- **File Handling**: We covered techniques for saving and loading files.
- **Black Boxing**: We applied the concept of black boxing, where we can provide an input and expect a specific output from a black box, such as our Permutation Indexer.

## Conclusion
Through this project, we gained valuable insights into modeling, problem-solving, and the practical application of various programming techniques and algorithms. This foundation can be extended to solve more complex problems in the field of AI and beyond.
